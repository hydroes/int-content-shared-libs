'use strict'
/* global dust */

var _ = require('underscore')

/**
 * Returns the DADI's CDN url for an image with options
 */
dust.helpers.imgcdn = function (chunk, context, bodies, params) {
  var result = ''

  if (!params.asset) {
    return chunk.write(result)
  }

  // See: https://github.com/dadi/cdn/blob/docs/docs/workingWithImages.md

  // domain and quality (including other defaults) can be set in
  // config/config.{env}.json
  var protocol = context.get('settings.protocol')
  var domain = context.get('settings.imageDomain')
  var quality = context.get('settings.imageQuality')
  var asset = context.resolve(params.asset)

  var template = '{protocol}{domain}/{path}/{fileName}'
  template = template.replace('{protocol}', protocol)
  template = template.replace('{domain}', domain)
  template = template.replace('{path}', asset.path || '')
  template = template.replace('{fileName}', encodeURIComponent(asset.fileName) || '')

  var options = [
    'quality',
    'trim',
    'trimFuzz',
    'width',
    'height',
    'cropX',
    'cropY',
    'ratio',
    'devicePixelRatio',
    'gravity',
    'filter',
    'blur',
    'strip',
    'rotate',
    'flip',
    'srcData',
    'resizeStyle'
  ]

  var cropDimensions
  // check of there is crop data associated with this image
  if (params.cropData && params.cropType) {
    // workout which crop 'tag' to use
    var searchCriteria = {'_field': params['cropType']}
    var cropInfo = _.findWhere(params['cropData'], searchCriteria)

    // crop data can be passed directly to this method as it comes from different
    // formats from the api
    if (!cropInfo) {
      var potentialImageData = _.first(params['cropData'])
      if (potentialImageData && potentialImageData['_image']) {
        cropInfo = potentialImageData
      }
    }

    if (typeof cropInfo === 'object' && cropInfo !== null) {
      // workout crop dimensions
      cropDimensions = []
      cropDimensions['top'] = parseInt(cropInfo.y)
      cropDimensions['left'] = parseInt(cropInfo.x)
      cropDimensions['bottom'] = parseInt(cropInfo.y + cropInfo.height)
      cropDimensions['right'] = parseInt(cropInfo.x + cropInfo.width)

      // add crop data to options
      options.push('crop')
    }
  }

  // if this is set, then only params that are set are in put in the image url
  // eg if width is set then the url built will be:
  // http://cdn.example.com/path/to/file.jpg?width=100

  var separator = '?'
  var separated = false
  var len = options.length

  for (var i = 0; i < len; i++) {
    var option = context.resolve(params[options[i]])

      // basically if crop data exists then add it and dont overwrite the orig
      // option if it was passed
    if (options[i] === 'crop' &&
      option === undefined) {
      option = cropDimensions['top'] + ',' + cropDimensions['left'] + ',' + cropDimensions['bottom'] + ',' + cropDimensions['right']
    }

      // default image quality
    if (options[i] === 'quality' &&
      option === undefined) {
      option = quality
    }

    if (option !== undefined) {
      if (separated === true) separator = '&'
      template += separator + options[i] + '={' + option + '}'
      template = template.replace('{' + option + '}', option)
      separated = true
    }
  }

    // if cropdata exists then add the resize flag on
  if (typeof cropDimensions !== 'undefined') {
    template += '&resize=crop'
  }
  template += '&format=jpg'

  result = template

  /*
  '?format={format}' +            // jpg, png, json
-     '&quality={quality}' +            // 0-100
-     '&trim={trim}' +              // 0-1
-     '&trimFuzz={trimFuzz}' +          // 0-1
-     '&width={width}' +              // (pixels) integer
-     '&height={height}' +            // (pixels) integer
-     // '&crop-x={crop-x}' +              removed because params obsolete
-     // '&crop-y={crop-y}' +             // removed because params obsolete
-     '&ratio={ratio}' +              // e.g. 1-1, 4-3, 16-9, 21-9
-     '&devicePixelRatio={devicePixelRatio}' +  // 0, 1, 2, 3
-     '&gravity={gravity}' +            // [all compass bearings], center, none
-     '&filter={filter}' +            // 0, Lagrange, Lanczos
-     '&blur={blur}' +              // int
-     '&strip={strip}' +              // bool
-     '&rotate={rotate}' +            // 0-359
-     '&flip={flip}' +                // bool
-     '&srcData={srcData}' +            // TBC (docs say: "Path to the source file")
-     '&resizeStyle={resizeStyle}' +        // 'aspectfill', 'aspectfit', 'fill', 'crop'

  http://bauer.radio.test.cdn.dadi.technology//?format=jpg&quality=80&trim=0&trimFuzz=0&width=0&height=0&crop-x=0&crop-y=0&ratio=0&devicePixelRatio={devicePixelRatio}&gravity=0&filter=0&blur=0&strip=0&rotate=0&flip=0&srcData={srcData}
  */

  return chunk.write(result)
}

'use strict'
/* global dust */
dust.helpers.link = function (chunk, context, bodies, params) {
  var article = context.resolve(params.article)
  var channel = context.resolve(params.channel) // Now explictly passing channel

  return '/' +
        channel +
        '/' +
        article.categories[0].parent.furl +
        '/' +
        article.categories[0].furl +
        '/' +
        article.furl
}

var dust = require('dustjs-linkedin')
var _ = require('underscore')

/*
* Paginate pages
* Usage:
* Send in current page, total pages, and a pattern for the path to generate.
* In the path pattern, use the  dust variable `n` where you want the page number inserted.
* ```
* {@paginate page=currentPageNumber totalPages=totalPageCount path="/page/{n}"}
*   <a href="{path}">{n}</a>
* {:current}
*   <a href="{path}">Current page {n}</a>
* {:prev}
*   <a href="{path}">Prev</a>
* {:next}
*   <a href="{path}">Next</a>
* {/paginate}
* ```
*/
dust.helpers.paginate = function (chunk, context, bodies, params) {
  var err

  if (!('page' in params && 'totalPages' in params && 'path' in params)) {
    err = new Error('Insufficient information provided to @paginate helper')
  }

  var current = parseInt(params.page, 10)
  var totalPages = parseInt(params.totalPages, 10)

  if (!(isFinite(current) && isFinite(totalPages))) {
    err = new Error('Parameters provided to @paginate helper are not integers')
  }

  var paginateContext = {
    n: current,
    path: ''
  }

  if (err) {
    console.log(err)
    return chunk
  }

  context = context.push(paginateContext)

  function printStep (body, n) {
    paginateContext.n = n
    paginateContext.path = context.resolve(params.path)

    if (n === 1) {
      // this is to make the path just the base path, without the number
      paginateContext.path = (paginateContext.path || '').replace(/1\/?$/, '')
    }

    chunk.render(body, context)
  }

  var printGap = bodies.gap ? printStep.bind(null, bodies.gap) : function () {}

  function printStepOrGap (step) {
    if (step === '.') {
      printGap()
    } else {
      printStep(bodies.block, step)
    }
  }

  function getStepSize (distance) {
    if (distance > 550) {
      return 500
    } else if (distance > 110) {
      return 100
    } else if (distance > 53) {
      return distance - 25
    } else if (distance > 23) {
      return distance - 10
    } else if (distance >= 10) {
      return distance - 5
    } else if (distance >= 5) {
      return distance - 2
    } else {
      return 1
    }
  }

  function makeSteps (start, end, tightness) {
    // start & end are non-inclusive
    var now
    var final
    var stepSize
    var steps = []

    if (tightness === 'increase') {
      now = start
      final = end
      while (now < final) {
        if (now !== start) {
          steps.push(now)
        }

        stepSize = getStepSize(final - now)

        if (stepSize > 1) {
          steps.push('.')
        }

        now += stepSize
      }
    } else { // decrease
      now = end
      final = start

      while (now > final) {
        if (now !== end) {
          steps.push(now)
        }

        stepSize = getStepSize(now - final)

        if (stepSize > 1) {
          steps.push('.')
        }

        now -= stepSize
      }

      steps.reverse()
    }

    return steps
  }

  // Only one page
  if (!totalPages || totalPages === 1) {
    if (bodies.else) {
      return chunk.render(bodies.else, context)
    }
    return chunk
  }

  if (current > 1) {
    // Prev
    if (bodies.prev) {
      printStep(bodies.prev, current - 1)
    }
    // First step
    printStep(bodies.block, 1)
    // Pre current
    _.each(makeSteps(1, current, 'increase'), printStepOrGap)
  }

  // Current
  printStep(bodies.current, current)

  if (current < totalPages) {
    // Post current
    _.each(makeSteps(current, totalPages, 'decrease'), printStepOrGap)
    // Last step
    printStep(bodies.block, totalPages)
    // Next
    if (bodies.next) {
      printStep(bodies.next, current + 1)
    }
  }

  return chunk
}
'use strict'
/* global dust */

dust.helpers.primarySyndicate = function (chunk, context, bodies, params) {
  var urls = context.resolve(params.urls)
  var channel = context.resolve(params.channel) // Now explictly passing channel

  var result = ''

  for (var i = urls.length - 1; i >= 0; i--) {
    if (urls[i].split('/')[0] === channel) {
      console.log('Match', urls[i].split('/')[0] + '| ' + channel)
      result = '/' + urls[i]
    }
  }

  return result
}

'use strict'
/* global dust */

var moment = require('moment')

/**
 * Returns the supplied timestamp parameter as a relative date
 *
 * If the relative time is more than an a day, the format is: DD MM YYYY
 * If the relative time is less than a day, but more than an hour the format is: HH hours ago
 * If the relative time is less than an hour, the format is: mm mins ago
 *
 * @example: {@relativeTimeUTC timestamp="2016-03-04T14:29:11.000Z" /}
 * @return string
 */
dust.helpers.relativeTimeUTC = function (chunk, context, bodies, params) {
  var result = ''

  try {
    var timestamp = parseInt(context.resolve(params.timestamp))

        // as timestamps are given from various api with or without milliseconds
        // check whether this timestamp needs miliiseconds added to it
    if (String(timestamp).length <= 10) {
      timestamp *= 1000
    }

    var time = moment(timestamp)
    var now = moment.utc()

    if (now.diff(time, 'days') > 0) {
      result = time.format('DD MM YYYY')
    } else {
      var hourDifference = now.diff(time, 'hours')
      if (hourDifference < 1) {
        var duration = moment.duration(now.diff(time))
        result = Math.round(duration.asMinutes()) + ' mins ago'
      } else {
        result = hourDifference + (hourDifference === 1 ? ' hour' : ' hours') + ' ago'
      }
    }
  } catch (err) {
        // Here be dragons
    console.log('relativeTimeUTC conversion error' + err)
  }

  return result
}

'use strict'
/* global dust */

dust.helpers.syndicateCategoryLink = function (chunk, context, bodies, params) {
  var article = context.resolve(params.article)
  var channel = context.resolve(params.channel)
  var displaySyndicate = context.resolve(params.displaySyndicate) || false
    // Logic flow:
    // find the publication position for the given category (publications)
    // use position in composed.categories to get the category id
    // display the category with the id found in categories

  if (!article || !article.publications) {
    return ''
  }

  var categoryId

  if (displaySyndicate === true) {
    categoryId = article.composed.categories[article.primarySyndicatePosition]
  } else {
    var publicationPos = false
    for (var n in article.publications) {
      if (channel === article.publications[n].furl) {
        publicationPos = n
      }
    }
    categoryId = article.composed.categories[publicationPos]
  }

  for (var n in article.categories) { // eslint-disable-line
    if (article.categories[n]._id === categoryId) {
            // /{params.channel}/{categories[0].parent.furl}/{categories[0].furl}/
      return '/' + channel + '/' + article.categories[n].parent.furl + '/' +
        article.categories[n].furl + '/'
    }
  }

    // var categoryId = article.composed.categories[article.primarySyndicatePosition];

    // for (var n in article.categories) {
    //     if (article.categories[n]._id === categoryId) {
    //         // /{params.channel}/{categories[0].parent.furl}/{categories[0].furl}/
    //         return '/' + channel + '/' + article.categories[n].parent.furl + '/'
    //             + article.categories[n].furl + '/';

    //     }
    // }
}

'use strict'
/* global dust */

dust.helpers.syndicateCategory = function (chunk, context, bodies, params) {
  var article = context.resolve(params.article)
  var channel = context.resolve(params.channel)
  var displayField = context.resolve(params.displayField) || 'name'
  var displaySyndicate = context.resolve(params.displaySyndicate) || false

    // Logic flow:
    // find the publication position for the given category (publications)
    // use position in composed.categories to get the category id
    // display the category with the id found in categories

  if (!article || !article.publications) {
    return ''
  }

  var categoryId

  if (displaySyndicate === true) {
    categoryId = article.composed.categories[article.primarySyndicatePosition]
  } else {
    var publicationPos = false
    for (var n in article.publications) {
      if (channel === article.publications[n].furl) {
        publicationPos = n
      }
    }
    categoryId = article.composed.categories[publicationPos]
  }

  for (var n in article.categories) { // eslint-disable-line
    if (article.categories[n]._id === categoryId) {
      if (displayField === 'parent') {
        return article.categories[n]['parent']['name']
      }
      return article.categories[n][displayField]
    }
  }
  return ''
}

'use strict'
/* global dust */
/**
 * Truncate string helper
 */
dust.helpers.truncateString = function (chunk, context, bodies, params) {
  var result = ''

  if (params.string) {
    var str = context.resolve(params.string)

    var strLength = parseInt(context.resolve(params.length))

    try {
      if (str.length > strLength) {
        result = str.substring(0, strLength) + '\u2026'
      } else {
        result = str
      }
    } catch (err) {
      result = str
    }
  }

  return chunk.write(result)
}
